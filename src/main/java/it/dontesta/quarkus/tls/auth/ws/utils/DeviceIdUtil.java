/*
 * Copyright (c) 2024 Antonio Musarra's Blog.
 * SPDX-License-Identifier: MIT
 */

package it.dontesta.quarkus.tls.auth.ws.utils;

import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.Base64;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import org.eclipse.microprofile.config.ConfigProvider;

/**
 * Utility class for generating and verifying Device IDs.
 *
 * <p>A Device ID is a unique identifier that can be used to identify a device.
 * It is generated by combining a timestamp, UUID, and hostname, and then generating an HMAC SHA-256
 * hash based on the combined string and a secret key. The Device ID is then encoded in Base64.
 *
 * <p>The Device ID can be verified by decoding the Base64 encoded string, splitting it into its
 * components, regenerating the HMAC from the combined string, and comparing the provided HMAC with
 * the calculated HMAC.
 *
 * <p>The secret key used for generating the HMAC is read from the configuration.
 *
 * @author Antonio Musarra
 * @see Base64
 * @see Mac
 * @see SecretKeySpec
 */
public class DeviceIdUtil {

  /**
   * Generates a Device ID and returns it encoded in Base64.
   *
   * @return Base64 encoded Device ID
   */
  public static String generateDeviceId() {
    // Generate a unique string based on timestamp, UUID, and hostname
    String timestamp = String.valueOf(System.currentTimeMillis());
    String uuid = java.util.UUID.randomUUID().toString().toLowerCase();
    String hostname = java.net.InetAddress.getLoopbackAddress()
        .getHostName(); // Replace with actual hostname if necessary

    // Combine the information using # as the separator
    String combinedString = String.join("#", timestamp, uuid, hostname);

    // Generate an HMAC SHA-256 based on the combined string and the secret key
    String hmac = generateHmacSha256(combinedString, staticSecretKey);

    // Combine the device ID with the HMAC
    String deviceId = String.join("#", combinedString, hmac);

    // Encode the result using Base64
    return Base64.getUrlEncoder().encodeToString(deviceId.getBytes(StandardCharsets.UTF_8));
  }

  /**
   * Verifies the provided Base64 encoded Device ID.
   *
   * @param encodedDeviceId Base64 encoded Device ID to verify
   * @return true if the Device ID is valid, false otherwise
   */
  public static boolean verifyDeviceId(String encodedDeviceId) {
    if (encodedDeviceId == null) {
      return false;
    }

    String deviceIdToVerify;

    try {
      // Decode the Base64 encoded Device ID
      deviceIdToVerify = new String(Base64.getUrlDecoder().decode(encodedDeviceId), StandardCharsets.UTF_8);
    } catch (IllegalArgumentException e) {
      return false; // Invalid Base64 encoding
    }

    // Split the decoded Device ID into its components
    String[] parts = deviceIdToVerify.split("#");
    if (parts.length != 4) {
      return false; // Invalid format
    }

    String combinedString = String.join("#", parts[0], parts[1], parts[2]);
    String hmacProvided = parts[3];

    // Regenerate the HMAC from the combined string
    String hmacCalculated = generateHmacSha256(combinedString, staticSecretKey);

    // Compare the provided HMAC with the calculated HMAC
    return hmacProvided.equalsIgnoreCase(hmacCalculated);
  }

  /**
   * Generates an HMAC SHA-256 hash.
   *
   * @param data Data to be hashed
   * @param key  Secret key used for hashing
   * @return Hex encoded HMAC
   */
  private static String generateHmacSha256(String data, String key) {
    try {
      Mac mac = Mac.getInstance("HmacSHA256");
      Key secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
      mac.init(secretKey);
      byte[] hmacBytes = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));

      StringBuilder hexString = new StringBuilder();
      for (byte b : hmacBytes) {
        hexString.append(String.format("%02x", b));
      }
      return hexString.toString();
    } catch (Exception e) {
      throw new RuntimeException("Failed to generate HMAC", e);
    }
  }

  private DeviceIdUtil() {
    throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
  }

  private static String staticSecretKey =
      ConfigProvider.getConfig().getValue("client.cert.device.id.secret-key", String.class);
}
